% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gamPoiTransform.R
\name{gamPoiTransform}
\alias{gamPoiTransform}
\title{Residual-based Variance Stabilizing Transformation}
\usage{
gamPoiTransform(
  data,
  offset_model = TRUE,
  residual_type = c("randomized_quantile", "pearson"),
  size_factors = TRUE,
  overdispersion = TRUE,
  overdispersion_shrinkage = TRUE,
  ridge_penalty = 2,
  return_fit = FALSE,
  verbose = FALSE,
  ...
)
}
\arguments{
\item{data}{any matrix-like object (e.g. matrix, DelayedArray, HDF5Matrix)
with one column per sample and row per gene. It can also be an object of type \code{glmGamPoi},
in which case it is directly used to calculate the variance-stabilized values.}

\item{offset_model}{boolean to decide if \eqn{\beta_1} in \eqn{y = \beta_0 + \beta_1 log(sf)},
is set to 1 (i.e., treating the log of the size factors as an offset ) or is estimated per gene.
From a theoretical point, it should be fine to treat \eqn{\beta_1} as an offset, because a cell that is
twice as big, should have twice as many counts per gene (without any gene-specific effects).
However, \code{sctransform} suggested that it would be advantageous to nonetheless estimate
\eqn{\beta_0} as it may counter data artifacts. On the other side, Lause et al. (2020)
demonstrated that the estimating \eqn{\beta_0} and \eqn{\beta_1} together can be difficult. If
you still want to fit \code{sctransform}'s model, you can set the \code{ridge_penalty} argument to a
non-zero value, which shrinks \eqn{\beta_1} towards 1 and resolved the degeneracy. \cr
Default: \code{TRUE}.}

\item{residual_type}{a string that specifies what kind of residual is returned as variance stabilized-value.
\describe{
\item{\code{"randomized_quantile"}}{The discrete nature of count distribution stops simple transformations from
obtaining a truly standard normal residuals. The trick of of quantile randomized residuals is to match the
cumulative density function of the Gamma-Poisson and the Normal distribution. Due to the discrete nature of
Gamma-Poisson distribution, a count does not correspond to a single quantile of the Normal distribution, but
to a range of possible value. This is resolved by randomly choosing one of the mapping values from the
Normal distribution as the residual. This ensures perfectly normal distributed
residuals, for the cost of introducing randomness. More details are available in the documentation
of \code{\link[statmod:qresiduals]{statmod::qresiduals()}} and the corresponding publication by Dunn and Smyth (1996).}
\item{\code{"pearson"}}{The Pearson residuals are defined as \eqn{res = (y - m) / sqrt(m + m^2 * theta)}.}
}
Default: \code{"randomized_quantile"}}

\item{overdispersion, overdispersion_shrinkage, size_factors}{arguments that are passed to the underlying
call to \code{\link[glmGamPoi:glm_gp]{glmGamPoi::glm_gp()}}. Default for each: \code{TRUE}.}

\item{ridge_penalty}{another argument that is passed to \code{\link[glmGamPoi:glm_gp]{glmGamPoi::glm_gp()}}. It is ignored if
\code{offset_model = TRUE}. Default: \code{2}.}

\item{return_fit}{boolean to decide if the matrix of residuals is returned directly (\code{return_fit = FALSE})
or if in addition the \code{glmGamPoi}-fit is returned (\code{return_fit = TRUE}) . Default: \code{FALSE}.}

\item{verbose}{boolean that decides if information about the individual steps are printed.
Default: \code{FALSE}}

\item{...}{additional parameters passed to \code{\link[glmGamPoi:glm_gp]{glmGamPoi::glm_gp()}}.}
}
\description{
Fit an intercept Gamma-Poisson model that corrects for sequencing depth and return the residuals
as variance stabilized results for further downstream application, for which no proper count-based
method exist or is performant enough (e.g., clustering, dimensionality reduction).
}
\examples{
 # Make example data
 n_genes <- 100
 n_cells <- 200
 beta0 <- rnorm(n = n_genes, mean = 2, sd = 0.3)
 beta1 <- rnorm(n = n_genes, mean = 0, sd = 2.5)
 X <- cbind(1, rep_len(c(-1,1), n_cells))
 sf <- rchisq(n = n_cells, df = 100)
 sf <- sf / mean(sf)
 Mu <- exp( cbind(beta0, beta1) \%*\% t(X) +
       matrix(log(sf), nrow = n_genes, ncol = n_cells, byrow = TRUE) )

 # Generate count data
 Y <- matrix(rnbinom(n = n_genes * n_cells, mu = Mu, size = 0.1),
             nrow = n_genes, ncol = n_cells)

 # Apply VST
 vst <- gamPoiTransform(Y, verbose = TRUE)

 # Plot the PCA of the result
 vst_pca <- prcomp(t(vst), rank. = 2)
 plot(vst_pca$x, col = as.factor((X[,2] == -1)))

}
\references{
Ahlmann-Eltze, Constantin, and Wolfgang Huber. "glmGamPoi: Fitting Gamma-Poisson Generalized Linear
Models on Single Cell Count Data." Bioinformatics (2020)

Dunn, Peter K., and Gordon K. Smyth. "Randomized quantile residuals." Journal of Computational and
Graphical Statistics 5.3 (1996): 236-244.

Hafemeister, Christoph, and Rahul Satija. "Normalization and variance stabilization of single-cell
RNA-seq data using regularized negative binomial regression." Genome biology 20.1 (2019): 1-15.

Hafemeister, Christoph, and Rahul Satija. "Analyzing scRNA-seq data with the sctransform and offset
models." (2020)

Lause, Jan, Philipp Berens, and Dmitry Kobak. "Analytic Pearson residuals for normalization of
single-cell RNA-seq UMI data." bioRxiv (2020).
}
\seealso{
\code{\link[glmGamPoi:glm_gp]{glmGamPoi::glm_gp()}}, \code{\link[glmGamPoi:residuals.glmGamPoi]{glmGamPoi::residuals.glmGamPoi()}}, \code{\link[sctransform:vst]{sctransform::vst()}},
\code{\link[statmod:qresiduals]{statmod::qresiduals()}}
}
